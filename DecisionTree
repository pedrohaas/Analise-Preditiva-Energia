import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import seaborn as sns
from scipy import stats
import matplotlib.patches as patches
import matplotlib
import warnings
warnings.filterwarnings('ignore')

# Função para criar uma árvore de decisão horizontal com as classes de preço
def criar_arvore_horizontal_classes(df_distribuicao, producao_excedente=70000):
    """
    Cria uma visualização de árvore horizontal onde:
    - O nó raiz representa a produção excedente
    - Cada nó secundário representa uma classe de preço com sua respectiva E(Receita)
    
    Args:
        df_distribuicao: DataFrame com as classes de preço
        producao_excedente: Produção de energia excedente em MWh
    """
    plt.figure(figsize=(18, 10))
    
    # Calcular a receita esperada total (ponderada pela frequência)
    df_receita = df_distribuicao.copy()
    df_receita['E(Receita)'] = df_receita['Ponto médio'] * producao_excedente
    
    # Calcular a receita ponderada total
    df_receita['Receita_Ponderada'] = df_receita['E(Receita)'] * df_receita['Frequência'] / 100
    receita_esperada_total = df_receita['Receita_Ponderada'].sum()
    
    # Configurar o canvas para desenho manual da árvore
    ax = plt.gca()
    ax.set_xlim(0, 100)
    ax.set_ylim(0, 100)
    ax.axis('off')  # Desativar eixos
    
    # Desenhar o nó raiz (retângulo com cantos arredondados)
    raiz_largura = 20
    raiz_altura = 10
    raiz_x = 5
    raiz_y = 45  # Centralizar verticalmente
    
    # Desenhar o retângulo do nó raiz com cantos arredondados
    retangulo_raiz = patches.FancyBboxPatch(
        (raiz_x, raiz_y), raiz_largura, raiz_altura,
        boxstyle=patches.BoxStyle("Round", pad=0.6, rounding_size=2),
        facecolor='lightblue', edgecolor='black', linewidth=1.5
    )
    ax.add_patch(retangulo_raiz)
    
    # Adicionar texto ao nó raiz
    plt.text(raiz_x + raiz_largura/2, raiz_y + raiz_altura*0.7, 
             "Colheita integral", ha='center', va='center', fontsize=11, fontweight='bold')
    plt.text(raiz_x + raiz_largura/2, raiz_y + raiz_altura*0.3, 
             f"Produção de excedente:\n{producao_excedente:,} MWh".replace(',', '.'), 
             ha='center', va='center', fontsize=9)
    
    # Adicionar a receita esperada total debaixo do nó raiz
    plt.text(raiz_x + raiz_largura/2, raiz_y - 5, 
             f"E(Receita): R$ {receita_esperada_total:,.2f}".replace(',', '.').replace('.', ','), 
             ha='center', va='center', fontsize=10, fontweight='bold')
    
    # Desenhar o círculo de conexão à direita do nó raiz
    circulo_x = raiz_x + raiz_largura + 5
    circulo_y = raiz_y + raiz_altura/2
    circulo = plt.Circle((circulo_x, circulo_y), 2, facecolor='white', edgecolor='black', linewidth=1.5)
    ax.add_patch(circulo)
    
    # Desenhar os nós secundários (classes de preço)
    num_classes = len(df_receita)
    altura_total_nos = 90  # Altura disponível para os nós secundários
    altura_no = min(8, altura_total_nos / num_classes * 0.8)  # Altura de cada nó, com espaço entre eles
    espaco_entre_nos = (altura_total_nos - altura_no * num_classes) / (num_classes - 1) if num_classes > 1 else 0
    
    # Início Y para os nós (para centralizar verticalmente)
    y_inicio = (100 - altura_total_nos) / 2 + altura_no/2
    
    # Largura dos nós secundários
    largura_no = 30
    
    # Posição X para os nós secundários
    x_nos = 55
    
    # Para cada classe, criar um nó retangular
    for i, (_, row) in enumerate(df_receita.iterrows()):
        # Posição Y do nó atual
        y_no = y_inicio + i * (altura_no + espaco_entre_nos)
        
        # Calcular a receita esperada
        receita = row['Ponto médio'] * producao_excedente
        
        # Desenhar o retângulo
        retangulo_classe = patches.Rectangle(
            (x_nos, y_no - altura_no/2), largura_no, altura_no,
            facecolor='white', edgecolor='black', linewidth=1
        )
        ax.add_patch(retangulo_classe)
        
        # Adicionar texto ao nó (preço da energia e E(Receita))
        plt.text(x_nos + largura_no/2, y_no + altura_no*0.1, 
                 f"Preço da energia: R$ {row['Ponto médio']:.2f}".replace('.', ','), 
                 ha='center', va='center', fontsize=10)
        plt.text(x_nos + largura_no/2, y_no - altura_no*0.3, 
                 f"E(Receita): R$ {receita:,.2f}".replace(',', '.').replace('.', ','), 
                 ha='center', va='center', fontsize=10)
        
        # Adicionar linha de conexão entre o círculo e o nó da classe
        plt.plot([circulo_x + 2, x_nos], [circulo_y, y_no], 'k-', linewidth=1)
        
        # Adicionar o percentual de frequência na linha de conexão
        plt.text((circulo_x + 2 + x_nos) / 2, (circulo_y + y_no) / 2 - 1, 
                 f"{row['Frequência']:.1f}%".replace('.', ','), 
                 ha='center', va='center', fontsize=9, 
                 bbox=dict(facecolor='white', edgecolor='none', boxstyle='round,pad=0.2'))
    
    plt.title('Árvore de Decisão para Classes de Preço da Energia', fontsize=16)
    plt.tight_layout()
    
    # Salvar e mostrar a árvore
    plt.savefig('arvore_classes_preco_energia.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return df_receita

# Função principal para executar todas as análises
def main():
    # Ativar modo interativo
    plt.ion()
    
    # Carregar os dados do arquivo Excel
    try:
        df = pd.read_excel("Historico_do_Preco_Medio_Mensal_-_janeiro_de_2001_a_abril_de_2025.xls")
        print("Dados carregados com sucesso!")
    except Exception as e:
        print(f"Erro ao carregar o arquivo: {str(e)}")
        # Se não conseguir carregar, usamos dados fictícios para demonstração
        print("Criando dados fictícios para demonstração...")
        
        # Criar série temporal fictícia
        datas = pd.date_range(start='2001-01-01', end='2025-04-01', freq='M')
        df = pd.DataFrame({
            'MES': datas,
            'SUDESTE': np.random.normal(500, 150, len(datas)) + np.linspace(0, 300, len(datas))
        })
    
    # Preparação dos dados
    df['MES'] = pd.to_datetime(df['MES'])
    df_sudeste = df[['MES', 'SUDESTE']].dropna()
    df_sudeste['ANO'] = df_sudeste['MES'].dt.year
    df_sudeste['MES_NUM'] = df_sudeste['MES'].dt.month
    
    # Criar a tabela de distribuição
    print("\n=== Criando Tabela de Distribuição de Classes de Preço ===")
    max_global = df_sudeste['SUDESTE'].max()
    min_global = df_sudeste['SUDESTE'].min()
    amplitude = max_global - min_global
    n_dados = len(df_sudeste)
    n_classes = int(np.sqrt(n_dados))
    intervalo_classe = 100  # Usando 100 como no exemplo
    
    valor_minimo_arredondado = 0  # Começando de 0
    valor_maximo_arredondado = (np.ceil(max_global / intervalo_classe) * intervalo_classe).astype(int)
    
    limites = np.arange(valor_minimo_arredondado, valor_maximo_arredondado + intervalo_classe, intervalo_classe)
    
    # Criar as classes e calcular as ocorrências
    classes = []
    for i in range(len(limites) - 1):
        limite_inferior = limites[i]
        limite_superior = limites[i+1]
        
        # Contagem de ocorrências
        if i == len(limites) - 2:  # Última classe, incluir o limite superior
            ocorrencias = ((df_sudeste['SUDESTE'] >= limite_inferior) & 
                         (df_sudeste['SUDESTE'] <= limite_superior)).sum()
        else:
            ocorrencias = ((df_sudeste['SUDESTE'] >= limite_inferior) & 
                         (df_sudeste['SUDESTE'] < limite_superior)).sum()
        
        ponto_medio = (limite_inferior + limite_superior) / 2
        frequencia = round((ocorrencias / n_dados) * 100, 3)
        
        classes.append({
            'Classe': i + 1,
            'Limite inferior': limite_inferior,
            'Limite superior': limite_superior,
            'Ponto médio': ponto_medio,
            'Ocorrências': ocorrencias,
            'Frequência': frequencia
        })
    
    # Criar DataFrame para a tabela de distribuição
    df_distribuicao = pd.DataFrame(classes)
    
    # Exibir a tabela de distribuição
    print(df_distribuicao.to_string(index=False))
    
    # Verificar se estamos em um ambiente Jupyter
    try:
        from IPython.display import display
        display(df_distribuicao)
    except ImportError:
        pass
    
    # Criar e exibir a árvore horizontal com as classes
    print("\n=== Criando Árvore de Classes de Preço com E(Receita) ===")
    df_receita = criar_arvore_horizontal_classes(df_distribuicao, producao_excedente=70000)
    
    print("\n=== Análise Concluída! ===")
    print("A árvore foi exibida e salva como imagem.")
    
    # Desativar modo interativo e garantir que todos os gráficos sejam exibidos
    plt.ioff()
    plt.draw()
    plt.pause(0.001)

if __name__ == "__main__":
    main()
